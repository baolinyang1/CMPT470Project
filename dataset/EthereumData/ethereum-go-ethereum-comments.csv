Issue ID,Issue State,Issue Title,Comment ID,Author,Created At,Comment Body
24783,closed,all: more linters,1113344233,holiman,2022-04-29T13:59:19Z,"Ok fixing the context can be done here
```diff
diff --git a/cmd/clef/main.go b/cmd/clef/main.go
index f7c3adebc4..de528982c7 100644
--- a/cmd/clef/main.go
+++ b/cmd/clef/main.go
@@ -819,9 +819,9 @@ func confirm(text string) bool {
 
 func testExternalUI(api *core.SignerAPI) {
 
-	ctx := context.WithValue(context.Background(), ""remote"", ""clef binary"")
-	ctx = context.WithValue(ctx, ""scheme"", ""in-proc"")
-	ctx = context.WithValue(ctx, ""local"", ""main"")
+	connInfo := rpc.PeerInfo{Transport: ""in-proc"", RemoteAddr: ""localhost""}
+	ctx = context.WithValue(context.Background(), peerInfoContextKey{}, connInfo)
+
 	errs := make([]string, 0)
 
 	a := common.HexToAddress(""0xdeadbeef000000000000000000000000deadbeef"")
@@ -952,7 +952,11 @@ func testExternalUI(api *core.SignerAPI) {
 	{ // Metadata
 		api.UI.ShowInfo(""Please check if you see the Origin in next listing (approve or deny)"")
 		time.Sleep(delay)
-		api.List(context.WithValue(ctx, ""Origin"", ""origin.com""))
+
+		connInfo := rpc.PeerInfo{Transport: ""http""}
+		connInfo.HTTP.Origin = ""origin.com""
+
+		api.List(context.WithValue(ctx, peerInfoContextKey{}, connInfo))
 		expectResponse(""metadata - origin"", ""Did you see origin (origin.com)? [yes/no] "", ""yes"")
 	}
 
```
However, there are also a couple of these
```
			ctx = context.WithValue(ctx, ""node"", node)
```
in `p2p/simulations/http.go`"
24783,closed,all: more linters,1113631473,fjl,2022-04-29T19:00:23Z,"Damn, I did not consider unit testing when adding `rpc.PeerInfo`. I guess we need to export `func WithPeerInfo(context.Context, PeerInfo) context.Context` in package rpc."
24783,closed,all: more linters,1113632069,fjl,2022-04-29T19:01:14Z,"I now think you are right, we should disable the warning for now and deal with it in another PR."
24783,closed,all: more linters,1114898681,holiman,2022-05-02T13:42:15Z,"> I now think you are right, we should disable the warning for now and deal with it in another PR.

Then we should be good to go with this PR"
24783,closed,all: more linters,1115869012,karalabe,2022-05-03T08:48:09Z,"Wrt the unused stuff, it's a ""regression"" from a refactor from last year https://github.com/ethereum/go-ethereum/pull/22163/files. I guess @rjl493456442 wantd to split my mega test method into more digestible chunks or variations and some were not necessary at the end.

I'm all for double checking and getting rid of all dead code there, just let's make sure nothing was lost in translation."
24783,closed,all: more linters,1148782542,holiman,2022-06-07T14:52:06Z,"Rebased. It found that  these two unexported methods were actually unused, so I commented them out. @rjl493456442 should they have been used? Is that an error? 
```
// onRead tracks the newly loaded trie node and caches the rlp-encoded blob internally.
// Don't change the value outside of function since it's not deep-copied.
func (t *tracer) onRead(key []byte, val []byte) {
...

// getPrev returns the cached original value of the specified node.
func (t *tracer) getPrev(key []byte) []byte {
```"
30418,closed,"core/vm, cmd/evm: implement eof validation",2343324550,holiman,2024-09-11T11:03:03Z,"Added benchmarks, based on some of the worst-cases from the consensus-tests + fuzzing vectors. 
```
goos: linux
goarch: amd64
pkg: github.com/ethereum/go-ethereum/cmd/eofdump
cpu: 12th Gen Intel(R) Core(TM) i7-1270P
BenchmarkEofParse
BenchmarkEofParse/test-1
BenchmarkEofParse/test-1-8               1043824              1145 ns/op          17.47 MB/s         352 B/op          9 allocs/op
BenchmarkEofParse/test-2
BenchmarkEofParse/test-2-8                717020              1526 ns/op          13.77 MB/s         416 B/op         12 allocs/op
BenchmarkEofParse/test-3
BenchmarkEofParse/test-3-8                645865              1830 ns/op          12.56 MB/s         464 B/op         16 allocs/op
BenchmarkEofParse/test-4
BenchmarkEofParse/test-4-8                666870              1875 ns/op          12.27 MB/s         464 B/op         16 allocs/op
BenchmarkEofParse/test-5
BenchmarkEofParse/test-5-8                614787              2180 ns/op          11.01 MB/s         488 B/op         18 allocs/op
BenchmarkEofParse/test-6
BenchmarkEofParse/test-6-8                337408              3773 ns/op          21.20 MB/s        1064 B/op         35 allocs/op
BenchmarkEofParse/test-7
BenchmarkEofParse/test-7-8                   282           4462357 ns/op          11.00 MB/s     1058652 B/op      38282 allocs/op
BenchmarkEofParse/test-8
BenchmarkEofParse/test-8-8                342518              4078 ns/op          15.69 MB/s         934 B/op         35 allocs/op
BenchmarkEofParse/test-9
BenchmarkEofParse/test-9-8                301110              3716 ns/op          17.22 MB/s         934 B/op         35 allocs/op
BenchmarkEofParse/test-10
BenchmarkEofParse/test-10-8               288266              4832 ns/op           6.83 MB/s        1031 B/op         37 allocs/op
BenchmarkEofParse/test-11
BenchmarkEofParse/test-11-8               277754              4582 ns/op           7.20 MB/s        1031 B/op         37 allocs/op
BenchmarkEofParse/test-12
BenchmarkEofParse/test-12-8                  632           1874380 ns/op          13.11 MB/s      453325 B/op      18881 allocs/op
BenchmarkEofParse/test-13
BenchmarkEofParse/test-13-8               185851              6186 ns/op           5.50 MB/s        1696 B/op         40 allocs/op
BenchmarkEofParse/test-14
BenchmarkEofParse/test-14-8                97939             13215 ns/op           4.09 MB/s        3557 B/op         80 allocs/op
BenchmarkEofParse/test-15
BenchmarkEofParse/test-15-8               104028             13065 ns/op          11.48 MB/s        3557 B/op         80 allocs/op
BenchmarkEofParse/test-16
BenchmarkEofParse/test-16-8                36811             36740 ns/op          14.59 MB/s       12777 B/op        279 allocs/op
BenchmarkEofParse/test-17
BenchmarkEofParse/test-17-8                 9140            117813 ns/op           6.25 MB/s       30370 B/op        739 allocs/op
BenchmarkEofParse/test-18
BenchmarkEofParse/test-18-8                 3262            368707 ns/op           2.83 MB/s      110391 B/op       2091 allocs/op
BenchmarkEofParse/test-19
BenchmarkEofParse/test-19-8               720025              1415 ns/op          22.62 MB/s         408 B/op         12 allocs/op
PASS
ok      github.com/ethereum/go-ethereum/cmd/eofdump     31.290s
```
"
30418,closed,"core/vm, cmd/evm: implement eof validation",2343618558,holiman,2024-09-11T13:04:50Z,"Sped it up quite a bit, the slowest vector is now improved by a factor of 10 :) 
```
goos: linux
goarch: amd64
pkg: github.com/ethereum/go-ethereum/cmd/eofdump
cpu: 12th Gen Intel(R) Core(TM) i7-1270P
                   │  eof.bench.1  │             eof.bench.2             │
                   │    sec/op     │    sec/op     vs base               │
EofParse/test-1-8     1.062µ ± ∞ ¹   1.105µ ± ∞ ¹        ~ (p=0.151 n=5)
EofParse/test-2-8     1.451µ ± ∞ ¹   1.442µ ± ∞ ¹        ~ (p=0.151 n=5)
EofParse/test-3-8     1.770µ ± ∞ ¹   1.533µ ± ∞ ¹  -13.39% (p=0.008 n=5)
EofParse/test-4-8     1.775µ ± ∞ ¹   1.550µ ± ∞ ¹  -12.68% (p=0.008 n=5)
EofParse/test-5-8     2.035µ ± ∞ ¹   1.631µ ± ∞ ¹  -19.85% (p=0.008 n=5)
EofParse/test-6-8     3.484µ ± ∞ ¹   3.039µ ± ∞ ¹  -12.77% (p=0.008 n=5)
EofParse/test-7-8     3.990m ± ∞ ¹   2.896m ± ∞ ¹  -27.43% (p=0.008 n=5)
EofParse/test-8-8     3.868µ ± ∞ ¹   1.225µ ± ∞ ¹  -68.33% (p=0.008 n=5)
EofParse/test-9-8     3.765µ ± ∞ ¹   1.170µ ± ∞ ¹  -68.92% (p=0.008 n=5)
EofParse/test-10-8    4.252µ ± ∞ ¹   1.838µ ± ∞ ¹  -56.77% (p=0.008 n=5)
EofParse/test-11-8    4.727µ ± ∞ ¹   1.829µ ± ∞ ¹  -61.31% (p=0.008 n=5)
EofParse/test-12-8    1.745m ± ∞ ¹   1.106m ± ∞ ¹  -36.63% (p=0.008 n=5)
EofParse/test-13-8    5.778µ ± ∞ ¹   1.836µ ± ∞ ¹  -68.22% (p=0.008 n=5)
EofParse/test-14-8   12.637µ ± ∞ ¹   2.335µ ± ∞ ¹  -81.52% (p=0.008 n=5)
EofParse/test-15-8   12.224µ ± ∞ ¹   2.856µ ± ∞ ¹  -76.64% (p=0.008 n=5)
EofParse/test-16-8    33.30µ ± ∞ ¹   15.61µ ± ∞ ¹  -53.12% (p=0.008 n=5)
EofParse/test-17-8   106.47µ ± ∞ ¹   11.42µ ± ∞ ¹  -89.27% (p=0.008 n=5)
EofParse/test-18-8   337.85µ ± ∞ ¹   27.20µ ± ∞ ¹  -91.95% (p=0.008 n=5)
EofParse/test-19-8    1.368µ ± ∞ ¹   1.365µ ± ∞ ¹        ~ (p=0.889 n=5)
geomean               11.30µ         5.055µ        -55.27%
¹ need >= 6 samples for confidence interval at level 0.95

                   │  eof.bench.1  │               eof.bench.2               │
                   │      B/s      │      B/s        vs base                 │
EofParse/test-1-8    17.96Mi ± ∞ ¹    17.27Mi ± ∞ ¹          ~ (p=0.151 n=5)
EofParse/test-2-8    13.80Mi ± ∞ ¹    13.89Mi ± ∞ ¹          ~ (p=0.151 n=5)
EofParse/test-3-8    12.39Mi ± ∞ ¹    14.31Mi ± ∞ ¹    +15.47% (p=0.008 n=5)
EofParse/test-4-8    12.36Mi ± ∞ ¹    14.15Mi ± ∞ ¹    +14.51% (p=0.008 n=5)
EofParse/test-5-8    11.24Mi ± ∞ ¹    14.04Mi ± ∞ ¹    +24.85% (p=0.008 n=5)
EofParse/test-6-8    21.90Mi ± ∞ ¹    25.11Mi ± ∞ ¹    +14.68% (p=0.008 n=5)
EofParse/test-7-8    11.74Mi ± ∞ ¹    16.17Mi ± ∞ ¹    +37.77% (p=0.008 n=5)
EofParse/test-8-8    15.78Mi ± ∞ ¹    49.84Mi ± ∞ ¹   +215.77% (p=0.008 n=5)
EofParse/test-9-8    16.21Mi ± ∞ ¹    52.18Mi ± ∞ ¹   +221.82% (p=0.008 n=5)
EofParse/test-10-8   7.401Mi ± ∞ ¹   17.118Mi ± ∞ ¹   +131.31% (p=0.008 n=5)
EofParse/test-11-8   6.657Mi ± ∞ ¹   17.204Mi ± ∞ ¹   +158.45% (p=0.008 n=5)
EofParse/test-12-8   13.43Mi ± ∞ ¹    21.20Mi ± ∞ ¹    +57.88% (p=0.008 n=5)
EofParse/test-13-8   5.608Mi ± ∞ ¹   17.662Mi ± ∞ ¹   +214.97% (p=0.008 n=5)
EofParse/test-14-8   4.072Mi ± ∞ ¹   22.058Mi ± ∞ ¹   +441.69% (p=0.008 n=5)
EofParse/test-15-8   11.70Mi ± ∞ ¹    50.09Mi ± ∞ ¹   +328.04% (p=0.008 n=5)
EofParse/test-16-8   15.35Mi ± ∞ ¹    32.74Mi ± ∞ ¹   +113.23% (p=0.008 n=5)
EofParse/test-17-8   6.590Mi ± ∞ ¹   61.455Mi ± ∞ ¹   +832.56% (p=0.008 n=5)
EofParse/test-18-8   2.947Mi ± ∞ ¹   36.602Mi ± ∞ ¹  +1142.07% (p=0.008 n=5)
EofParse/test-19-8   22.31Mi ± ∞ ¹    22.36Mi ± ∞ ¹          ~ (p=0.841 n=5)
geomean              10.65Mi          23.81Mi         +123.64%
¹ need >= 6 samples for confidence interval at level 0.95

                   │   eof.bench.1   │              eof.bench.2               │
                   │      B/op       │     B/op       vs base                 │
EofParse/test-1-8        352.0 ± ∞ ¹     352.0 ± ∞ ¹        ~ (p=1.000 n=5) ²
EofParse/test-2-8        416.0 ± ∞ ¹     416.0 ± ∞ ¹        ~ (p=1.000 n=5) ²
EofParse/test-3-8        464.0 ± ∞ ¹     424.0 ± ∞ ¹   -8.62% (p=0.008 n=5)
EofParse/test-4-8        464.0 ± ∞ ¹     424.0 ± ∞ ¹   -8.62% (p=0.008 n=5)
EofParse/test-5-8        488.0 ± ∞ ¹     440.0 ± ∞ ¹   -9.84% (p=0.008 n=5)
EofParse/test-6-8       1064.0 ± ∞ ¹    1016.0 ± ∞ ¹   -4.51% (p=0.008 n=5)
EofParse/test-7-8     1033.8Ki ± ∞ ¹   910.3Ki ± ∞ ¹  -11.95% (p=0.008 n=5)
EofParse/test-8-8        934.0 ± ∞ ¹     368.0 ± ∞ ¹  -60.60% (p=0.008 n=5)
EofParse/test-9-8        934.0 ± ∞ ¹     368.0 ± ∞ ¹  -60.60% (p=0.008 n=5)
EofParse/test-10-8      1031.0 ± ∞ ¹     472.0 ± ∞ ¹  -54.22% (p=0.008 n=5)
EofParse/test-11-8      1031.0 ± ∞ ¹     472.0 ± ∞ ¹  -54.22% (p=0.008 n=5)
EofParse/test-12-8     442.7Ki ± ∞ ¹   369.0Ki ± ∞ ¹  -16.64% (p=0.008 n=5)
EofParse/test-13-8      1697.0 ± ∞ ¹     472.0 ± ∞ ¹  -72.19% (p=0.008 n=5)
EofParse/test-14-8      3557.0 ± ∞ ¹     568.0 ± ∞ ¹  -84.03% (p=0.008 n=5)
EofParse/test-15-8      3557.0 ± ∞ ¹     984.0 ± ∞ ¹  -72.34% (p=0.008 n=5)
EofParse/test-16-8     12."
30418,closed,"core/vm, cmd/evm: implement eof validation",2376389242,fjl,2024-09-26T09:09:55Z,Let's move the new utility commands into cmd/evm. It's better to use an existing command.
30418,closed,"core/vm, cmd/evm: implement eof validation",2376392919,fjl,2024-09-26T09:11:36Z,"Would also be nice to remove some complexity in the validation code by moving statements out of `if`

```go
if have, want := currentStackMax, int(metadata[section].outputs)+int(newSection.inputs)-int(newSection.outputs); have != want {
```

should become

```go
wantStack := int(metadata[section].outputs)+int(newSection.inputs)-int(newSection.outputs)
if currentStackMax != wantStack {
```

And perhaps we can find a way to reduce conversions."
30418,closed,"core/vm, cmd/evm: implement eof validation",2376846439,holiman,2024-09-26T12:42:12Z,"> Let's move the new utility commands into cmd/evm. It's better to use an existing command.

Done

> Would also be nice to remove some complexity in the validation

Done

Also fixed up the `eofdump` command to print nicer output, and read from stdin if `--hex` is not given. Also made the commands use the std logging facilities more, not `fmt.Printf` so much (Note though: for `eofparse` it's part of the spec that it prints out ""OK"" or ""err..."" on stdout, so it can be used to compare across clients)"
30418,closed,"core/vm, cmd/evm: implement eof validation",2376873695,holiman,2024-09-26T12:54:24Z,"### `evm eofdump`

Example invocations of eofdump:

```
$ go run ./cmd/evm/ eofdump  --hex 0xef000101000402000100010400020000800000feaabb 
Header
  - EOFMagic: ef00
  - EOFVersion: 01
  - KindType: 01
  - TypesSize: 0004
  - KindCode: 02
  - KindData: 04
  - DataSize: 0002
  - Number of code sections: 1
    - Code section 0 length: 0001
  - Number of subcontainers: 0
Body
  - Type 0: 00800000
  - Code section 0: 0xfe
  - Data: 0xaabb
```
```
$ yes ""0xef000101000402000100010400020000800000feaabb"" | head -n2 | go run ./cmd/evm/ eofdump  
Header
  - EOFMagic: ef00
  - EOFVersion: 01
  - KindType: 01
  - TypesSize: 0004
  - KindCode: 02
  - KindData: 04
  - DataSize: 0002
  - Number of code sections: 1
    - Code section 0 length: 0001
  - Number of subcontainers: 0
Body
  - Type 0: 00800000
  - Code section 0: 0xfe
  - Data: 0xaabb

Header
  - EOFMagic: ef00
  - EOFVersion: 01
  - KindType: 01
  - TypesSize: 0004
  - KindCode: 02
  - KindData: 04
  - DataSize: 0002
  - Number of code sections: 1
    - Code section 0 length: 0001
  - Number of subcontainers: 0
Body
  - Type 0: 00800000
  - Code section 0: 0xfe
  - Data: 0xaabb

```
### `evm eofparse` 

Example invocation of `eofparse`
```
$ cat ./cmd/evm/testdata/eof/eof_corpus_1.txt | head -n10 | go run ./cmd/evm eofparse 
err: invalid container size: have 24, want 23
err: invalid container size: have 21, want 20
err: invalid container size: have 22, want 21
err: invalid max stack height in code section 0: have 0, want 48
err: invalid max stack height in code section 0: have 0, want 48
err: invalid container size: have 53, want 52
err: truncated immediate: op PUSH2, pos 1
err: invalid container size: have 38, want 37
err: invalid container size: have 48, want 47
err: invalid container size: have 48, want 47

```
"
31137,closed,cmd/devp2p/internal/ethtest: remove TD from status validation,2639622619,LukaszRozmej,2025-02-06T11:57:13Z,"Maybe there should be validation that this field exists, but not it's value?"
31137,closed,cmd/devp2p/internal/ethtest: remove TD from status validation,2641742725,rjl493456442,2025-02-07T01:55:42Z,@LukaszRozmej RLP-decoding will fail if this field is not present.
31140,closed,0xE8E12C1A60c11E8E75724656D74fc6f6f78B3324,2641012978,surewire1920,2025-02-06T21:02:06Z,I want to exchange with naira 
31140,closed,0xE8E12C1A60c11E8E75724656D74fc6f6f78B3324,2641017557,surewire1920,2025-02-06T21:04:37Z,0x498Dbe753741583f89d1Cd96E2969a43B3daD1DF
31140,closed,0xE8E12C1A60c11E8E75724656D74fc6f6f78B3324,2641022014,surewire1920,2025-02-06T21:07:16Z,"Anthony Godsgift 
2034265101
Kuda "
31085,closed,Removed `--dev` precompiles genesis balances,2620023220,jwasinger,2025-01-28T20:46:29Z,"From EIP-161:
> An account is considered empty when it has no code and zero nonce and zero balance.
> At the end of the transaction, any account touched by the execution of that transaction which is now empty SHALL instead become non-existent (i.e. deleted).

If we remove the balance from precompiled contracts, and a call executes a precompile without sending any balance:  the precompiled contract will be deleted.  A subsequent call to the precompile in a separate transaction will recreate the account (and execute the precompile). see https://github.com/ethereum/go-ethereum/blob/master/core/vm/evm.go#L191-L212 .

The change in this PR could cause deviation from mainnet behavior for operations that are priced based on the existence of an account (iirc EXTCODEHASH, EXTCODECOPY and perhaps others).

> The test case it enables is to send eth eth to a previously ""empty account"" precompiles.

From this description, I would guess that you are talking about a test case that sends a balance to a non-existent precompile which is later instantiated at a fork.  Although it's not clear from the description you have given.

Overall, I'd opt not to merge as this appears broken and it's not clear what the practical benefit is."
31085,closed,Removed `--dev` precompiles genesis balances,2620058240,maoueh,2025-01-28T21:07:32Z,"> If we remove the balance from precompiled contracts, and a call executes a precompile without sending any balance: the precompiled contract will be deleted. A subsequent call to the precompile in a separate transaction will recreate the account (and execute the precompile). see https://github.com/ethereum/go-ethereum/blob/master/core/vm/evm.go#L191-L212 .

That is correct and is the behavior that was happening on Mainnet ... before someone sent eth to precompile address(es). The genesis allocation for Mainnet has nothing set for precompiled addresses. This seems to me a fair argument that `--dev` also does not set those.

> The change in this PR could cause deviation from mainnet behavior for operations that are priced based on the existence of an account (iirc EXTCODEHASH, EXTCODECOPY and perhaps others).

I disagree with that assertion. If there is a difference, it's because people sent eth to precompiles addresses. There would be no differences against mainnet otherwise since they were not specified in the genesis allocation initially. 

> From this description, I would guess that you are talking about a test case that sends a balance to a non-existent precompile which is later instantiated at a fork. Although it's not clear from the description you have given.

I'm testing there first transaction on Mainnet that sent eth to a precompiles. Without the precompiles in genesis, you can test both cases easily, just send eth to a precompile to keep its account active.

Otherwise if always set, you cannot test the first case. "
31085,closed,Removed `--dev` precompiles genesis balances,2620156238,jwasinger,2025-01-28T22:08:41Z,"> I disagree with that assertion. If there is a difference, it's because people sent eth to precompiles addresses. There would be no differences against mainnet otherwise since they were not specified in the genesis allocation initially.

If I remove a precompile address from the genesis configuration, create a transaction where it is touched and deleted, create a subsequent transaction that `CALL`s the precompile, the second transaction will pay an additional cost to access a non-existent account and then execute the precompile.  This is behavior that can't happen on mainnet so clearly we shouldn't adopt it in dev mode.

IMO the proper approach to test the behavior of tracing of blocks/txs in historical forks would be to generate a test chain, import it and then reexecute/trace the historical blocks.  Would anything prevent you from using that approach to achieve what you are trying to do?"
31085,closed,Removed `--dev` precompiles genesis balances,2620166624,jwasinger,2025-01-28T22:15:20Z,I think `core/chain_makers.go` contains utilities you can use to generate a test chain.
31085,closed,Removed `--dev` precompiles genesis balances,2630947892,MariusVanDerWijden,2025-02-03T13:02:10Z,"I agree with @jwasinger's reasoning here. The behavior would change if we did not fund the precompile address. Since we want to mimic the behavior of mainnet as much as possible, it makes sense for prefunding the precompiles.

I will close this for now, thank you for your submission!"
31085,closed,Removed `--dev` precompiles genesis balances,2631778520,maoueh,2025-02-03T18:40:38Z,"Thanks for the review.

I would like still to better understand why this isn't considered closer to Mainnet actually. Not saying it isn't true/accurate, more that I do not clearly understand it.

We have:

- Genesis block (G)
- EIP-161 block (E)
- Future blocks (E+N)

Let's assume there was never a transaction sending eth to a precompile P never. That means that in E+N blocks, the account would indeed be created than deleted right away as it would be empty.

How is aligning the genesis allocations closer to Mainnet isn't in the spirit of being close to Mainnet. 

I understand that today, all precompiles are funded and thus, would diverge from Mainnet. But new precompiles for example, they would be initially funded, until someone decide to send eth there, most probably by mistake. It means there would be a timeframe where `--dev` would misalign with Mainnet.

All in all, I will comply with your decision of course. I'm genuinely curious about understanding the reasoning here and ensure I fully understand the overall Ethereum spec.

> I think core/chain_makers.go contains utilities you can use to generate a test chain.

That I 100% agree, it's the best place to test those behavior. I'm trying to port our old test suite which was using `geth + clique engine` to test ""real"" scenarios.

It's a fixture that we encountered on Mainnet, but I wasn't able to replicate it with `geth --dev`, hence my PR here. Hence why I'm of the opinion of not having the funded precompiles more closely align with Mainnet, at least in the genesis and not in state."
31085,closed,Removed `--dev` precompiles genesis balances,2633455025,s1na,2025-02-04T10:16:38Z,"@maoueh I understand your use-case. Let's see if we can find an alternative solution for you. First thing I thought of was seeding the --dev mode with a custom genesis. I am facing an issue here tho. I tried to do `geth --dev --datadir mydir dumpgenesis` and what I get is:

```
❯ ./build/bin/geth --dev --datadir mydir dumpgenesis
INFO [02-04|11:13:31.346] Maximum peer count                       ETH=50 total=50
INFO [02-04|11:13:31.352] Set global gas cap                       cap=50,000,000
INFO [02-04|11:13:31.452] Using developer account                  address=0xCd63a1A5bF5407dD90897B691C35aE248be03B3a
INFO [02-04|11:13:31.452] Defaulting to pebble as the backing database
INFO [02-04|11:13:31.452] Allocated cache and file handles         database=/Users/sina/dev/go/src/github.com/ethereum/go-ethereum/mydir/geth/chaindata cache=512.00MiB handles=5120
INFO [02-04|11:13:31.538] Opened ancient database                  database=/Users/sina/dev/go/src/github.com/ethereum/go-ethereum/mydir/geth/chaindata/ancient/chain readonly=false
INFO [02-04|11:13:31.538] Freezer shutting down
INFO [02-04|11:13:31.543] Initializing the KZG library             backend=gokzg
INFO [02-04|11:13:31.567] Using pebble as the backing database
INFO [02-04|11:13:31.567] Allocated cache and file handles         database=/Users/sina/dev/go/src/github.com/ethereum/go-ethereum/mydir/geth/chaindata cache=16.00MiB handles=16
Fatal: failed to read genesis: invalid genesis hash in database: 0000000000000000000000000000000000000000000000000000000000000000
```

The idea was to dump the genesis, modify the precompile balances and do `init` after that."
31085,closed,Removed `--dev` precompiles genesis balances,2633493301,s1na,2025-02-04T10:30:18Z,"Ok it works. My mistake was first I have to run the dev node so it persists the genesis block. The flow is:

- `geth --dev --datadir mydir`
- Stop
- `geth --dev --datadir mydir dumpgenesis`
- Remove precompile balances store it in file
- `geth --dev --datadir mydir2 init genesis.json`

Seems to do the trick."
31085,closed,Removed `--dev` precompiles genesis balances,2639960940,maoueh,2025-02-06T14:20:16Z,"@s1na Thank you very much, that is perfect for me indeed, I didn't know it was possible to pass a custom genesis to a dev env."
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1126006960,lispc,2022-05-13T12:31:53Z,"another approach is to add a flag named ""MemoryTraceMode"".  

MemoryTraceMode == 0: snapshot full memory every step; 
MemoryTraceMode == 1: snapshot full memory when updated;
MemoryTraceMode == 2: snapshot memory diff"
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1128804683,s1na,2022-05-17T12:25:26Z,"I agree this would be nice as traces are usually pretty heavy. We can deprecate `EnableMemory` and set `MemoryTraceMode` by default to a value that implies memory tracing is disabled for backwards-compatibility.

I'll mark it for triage to see what others think."
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1128904805,s1na,2022-05-17T13:56:44Z,Can you please try this [patch](https://github.com/s1na/go-ethereum/tree/logger/mem-dedup) on the mainnet block you mentioned and see if it makes a big difference?
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1129059211,s1na,2022-05-17T16:11:03Z,This PR might also be of interest: https://github.com/ethereum/go-ethereum/pull/24895. By streaming the traces geth shouldn't blow up but it comes with some networking overhead. I'm curious how it performs on a big tx.
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1132389318,lispc,2022-05-20T02:25:28Z,"I analyzed(traced with mem trace enabled) every tx inside the mentioned block. There are 94 txs in total, 93 of them can be traced successfully(the biggest trace is of ~300MiB size, summing all is about ~900MiB), [the failed one(always makes geth OOM) is an Arbitrum Sequencer tx](https://etherscan.io/tx/0x0ef22f22aa244bdbf2e6b49b6b36f71717f9d18c2a3d7b24be52ff26abd1a220), having calldata of ~100KiB. In the Arbitrum contract, the calldata are copied to memory and hashed. So snapshots of mem for every step will be HUGE.."
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1157402971,holiman,2022-06-16T08:50:06Z,"Triage discussion: an alternate variant would be to

> If memory changes between step N and N+1, then output the full memory at N+1. 


This means that at any scope-changing operation (revert, return, call-variants) at N, step N+1 would output the memory (unless it was empty in the old and new scope). And also output it at MSTORE/MSTORE8 ops. 

Such format change would bring down the output size __a lot__, but still make it pretty easy to build a non-intelligent traceviewer. I want to avoid forcing a traceviewer to become a mini-evm."
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,1210794414,s1na,2022-08-10T14:56:40Z,cc @yann300
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,2639561638,MariusVanDerWijden,2025-02-06T11:28:23Z,The StructLogger recently was made streamable in https://github.com/ethereum/go-ethereum/pull/30806 which should make it use way less memory
24873,closed,proposal: optimize the memory usage when EnableMemory = true for StructLogger ,2639664572,holiman,2025-02-06T12:15:35Z,Anything returned over http (at least our http rpc implementation) is inherently un-streamable. So this is still relevant.
24129,closed,Unpacking output of multicall abi ,997311606,fomotrader,2021-12-19T01:21:56Z,Hopefully I've provided enough information in this ticket for others that are more familiar with GETH to help me look into it and either correct my understanding or we can fix GETH.
24129,closed,Unpacking output of multicall abi ,1011982202,ligi,2022-01-13T10:05:48Z,"Can you provide more details like the ABI, tx and all that is needed to reproduce the issue?"
24129,closed,Unpacking output of multicall abi ,1048590869,WayneLiang,2022-02-23T09:29:09Z,"> Can you provide more details like the ABI, tx and all that is needed to reproduce the issue?

like this Transaction https://etherscan.io/tx/0xbfb3415b5f949519abfee01388ab0fb56edf5e4ac3f949086de6907f2387e64e.
abi Method is multicall, when unpacking the input data, it will return abi: cannot marshal in to go slice: offset 78063394979094799799290440606367866824566315126099565707416874105828244717600 would go over slice boundary (len=580)
"
24129,closed,Unpacking output of multicall abi ,2639581712,MariusVanDerWijden,2025-02-06T11:37:42Z,"As stated here, we decided not to enshrine a contract as stated here: https://github.com/ethereum/go-ethereum/pull/30416#issuecomment-2340665134
However unmarshalling output from Multicall abi should be pretty easy, especially with abigen v2 coming up which will make it easier to unmarshal single outputs, splitting the multicall output into multiple outputs of single calls should be pretty easy by the caller."
31088,closed,build: update EEST fixtures to prague devnet-6,2636826396,s1na,2025-02-05T13:14:37Z,"Hm we have a failing transaction test:

```
--- FAIL: TestExecutionSpecTransaction (0.00s)
    --- FAIL: TestExecutionSpecTransaction/prague/eip7702_set_code_tx/invalid_tx/empty_authorization_list.json (0.00s)
        transaction_test.go:75: expected error TransactionException.TYPE_4_EMPTY_AUTHORIZATION_LIST, got none (<nil>)
FAIL
FAIL	github.com/ethereum/go-ethereum/tests	509.565s
ok  	github.com/ethereum/go-ethereum/tests/fuzzers/bls12381	0.021s
```"
31088,closed,build: update EEST fixtures to prague devnet-6,2637296938,s1na,2025-02-05T15:46:21Z,@MariusVanDerWijden please take another look
31088,closed,build: update EEST fixtures to prague devnet-6,2638110136,lightclient,2025-02-05T21:56:52Z,"~~A little confused why CI didn't fail on the EEST transaction tests for 7702? Locally ran it and it failed on the empty auth list test which makes sense because we only check that during the state transition.~~

Sorry I accidentally pulled a stale version. I still think it is more correct to skip the test because aren't actually testing anything with it. We're just testing that the transaction test checker notices the auth list is empty. Better to eventually put all the prechecks in an exportable function and run it here like we can with `IntrinsicGas`."
31088,closed,build: update EEST fixtures to prague devnet-6,2638121302,lightclient,2025-02-05T22:00:59Z,Feel free to revert if you disagree.
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2171039737,Bitwise0x,2024-06-16T04:20:00Z,@karalabe @rjl493456442 @holiman
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2173682796,s1na,2024-06-17T15:14:02Z,"The gas returned is how much gas was used during the simulation. It is not necessarily a good estimate for submitting the tx. For that you should rather use `eth_estimateGas`.

Otherwise if it is inaccurate it helps if you demonstrate what you expect and what is returned."
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2175706132,Bitwise0x,2024-06-18T10:01:52Z,"@s1na 
Why is **debug_traceCall** not accurate when both **stateOverrides** and **blockOverrides** are used within the same call? I am trying to simulate my transaction beneath another transaction, and was expecting an accurate gasUsed.

debug_traceCall with just **blockOverrides** works perfectly. however, when combined with stateOverrides, it overestimates gas usage by approximately 5-15k.
"
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2184950091,s1na,2024-06-23T11:23:16Z,"@Bitwise0x This is a difficult question to answer. You are modifying the state, that can change the flow of execution and require a different amount of gas. When submitting on chain the state might not be the same as in your override though.

Ideally you give me something to reproduce."
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2295169924,Otto-AA,2024-08-18T08:08:33Z,"I'm not sure if this is the same issue the OP described, but here's a minimal example at Erigon: https://github.com/erigontech/erigon/issues/11254

I've tested it with Quicknode (Geth/v1.14.5-stable-0dd173a7/linux-amd64/go1.22.4) and it reports the same issue."
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2301556267,s1na,2024-08-21T09:11:06Z,"> debug_traceCall shows a lower gasCost for addresses, that were modified by the stateOverrides.

Based on this I thought maybe we consider the overridden storage as a dirty slot (in EIP-2200 terms). But that seems not to be the case.

I have this contract deployed:

```go
common.BytesToAddress([]byte{32}): {Code: common.Hex2Bytes(""600260055500""), Nonce: 1, Storage: map[common.Hash]common.Hash{common.BytesToHash([]byte{0x5}): common.BytesToHash([]byte{0x1})}}
```

Then do the following traceCall:

```
> debug.traceCall({ to: '0x0000000000000000000000000000000000000020', gas: '0x186a0' }, 'latest', { stateOverrides: { '0x0000000000000000000000000000000000000020': { stateDiff: { '0x0000000000000000000000000000000000000000000000000000000000000005': '0x0000000000000000000000000000000000000000000000000000000000000000' } } }})
```

I.e. the ""original"" value for the slot is 0x1. I change the ""current"" to 0x0. The code will write the value of 0x2 to the slot. So that should try to deduct some of the refund (and fail). But instead I get the ""correct"" gas cost for the SSTORE:

```js
{
      depth: 1,
      gas: 78994,
      gasCost: 22100,
      op: ""SSTORE"",
      pc: 4,
      stack: [""0x2"", ""0x5""],
      storage: {
        0000000000000000000000000000000000000000000000000000000000000005: ""0000000000000000000000000000000000000000000000000000000000000002""
      }
  }
```"
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2301586900,s1na,2024-08-21T09:26:22Z,"This clause commits the overrides so they are not considered dirty. And I'm pretty sure we don't add them to the access list either. So I can't think why addresses modified by stateOverrides should have a different gas cost.

https://github.com/ethereum/go-ethereum/blob/733fcbbc65bca69e28480f624e2aeb170c97cb3e/internal/ethapi/api.go#L1014-L1017"
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2304074227,fjl,2024-08-22T08:25:00Z,"@Bitwise0x again, could you please provide an example so we can reproduce and see the expected gas usage ourself?"
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2308493992,Bitwise0x,2024-08-24T18:49:36Z,"@fjl @s1na  when I tried to simulate the backrun transaction with stateoverrides, gas usage was significantly higher 

Signal: 0xfa64ed459ec08a373cb1555e4f11672da415d5e7562b768207b23bc225ae77f7
Backrun: 0x772bd92cf60fbcd76cffb27a04a141e8275a16bb483a8f7b6596552c70fad6e5"
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2334009038,Otto-AA,2024-09-06T13:05:41Z,"@s1na After spending some more hours on this issue, I think the issue I reported occurs only with Erigon. It seems that my provider transparently switches the used node based on the block number, which made me think I also reproduced it on Geth :(

Did you test the python script from the linked Erigon issue (repro.py.txt)? If you run it against a Geth instance and there is no ""Found first step with differences"" printed to the console, then it should be an Erigon-only issue and you can ignore my comments above. I can't find a public Geth instance to test it against."
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2345660604,gballet,2024-09-12T08:49:14Z,"@Bitwise0x any update on this? We need your input, and will close this issue otherwise. To be clear, your last response does not help us, we would like to know of a way to reproduce this issue. There's not much we can do otherwise."
29996,closed,debug_traceCall returning inaccurate gasUsed when both blockOverrides and stateOverrides are used,2639558200,MariusVanDerWijden,2025-02-06T11:26:49Z,We have decided to close this as we can not replicate the issue unfortunately. Thank you for submitting
30878,closed,block import is broken with verkle,2528475651,gballet,2024-12-09T15:51:56Z,"@holiman you wanted to have a way to reproduce the issue:

 * Get the kaustinen genesis block 
[genesis_kaustinen7.json](https://github.com/user-attachments/files/18064058/genesis_kaustinen7.json)
 * Run `go run ./cmd/geth --datadir=<dir> --cache.preimages --override.verkle=1730214000 init genesis.json`
 * Run `go run ./cmd/geth --datadir=<dir> --cache.preimages --override.verkle=1730214000 --bootnodes ""enode://548ff025abb1522c5257f50765abd21754b7ea7159a176a9b96c738ee6456fc378a11c09a62d55d92684634cd32a9cad498f5649256caf693dab77f961a169f6@167.235.68.89:30303?discport=30303,enode://7a46b1126d2c602e2d567a75aa3cc2577d93ea2bfcc524d115f985689516159c94a339f3984bbce28eb8b35d49494d1ec7be55f361c7768ae43993bc5b88eb77@128.140.104.94:30303?discport=30303,enode://a21d8ecaaea7a199a479672ae11b11afc1b55dce4851d278cae11fd4cf5452866f40890cb7262c3430f9f249d7091ebab39f148740c267f3f3b505c6d27391fe@128.140.104.96:30303?discport=30303,enode://145e00c57c837fe19d431bb33cb964b747616cc6be57e350936f13fe51ab4fab5bb167fb38c8399d9b0d687d317466d2c4d0bff2c83068ffa77c4ed16f5f7b28@195.201.139.113:30303?discport=30303,enode://9ceb22af386b10ba283cd60f7e83772585e47946e7dddc6029e9acd79730095ea8e5e6ba8619c30149e002084b9bb83ef62e0765cd30c9626667b29ea8f3389e@49.13.196.169:30303?discport=30303,enode://e1157ce974bd103852a6df269a772dbcf308f628b185e6fc2774f8eddc127c1309a7f023dfaae922dfe32c5170aa7085245dbe4b88931b21d3ee4bb290b77418@195.201.36.62:30303?discport=30303"" --authrpc.jwtsecret <secret> --syncmode full`
 
 Notice that it complains about the genesis hash being incorrect.
"
30878,closed,block import is broken with verkle,2528536309,gballet,2024-12-09T16:15:20Z,"The above comment points out that there is a much bigger issue than just block import: using a `nil` genesis block is no longer a workeable solution.

This causes [this line](https://github.com/ethereum/go-ethereum/blob/master/core/blockchain.go#L272) to consider that we are not in verkle mode, even when we are. But even if we could somehow set this flag properly, it will still be missing important information like the state root hash.

The inescapable conclusion, in my view is:
 * the whole genesis block needs to be loaded from the db each time the block is created. If it's in the DB, it should be assumed to be correct.
 * If  some compatibility checks are needed when ""updating"" the kernel, _then_ peform the checks in this very context."
30878,closed,block import is broken with verkle,2538076601,rjl493456442,2024-12-12T08:04:56Z,I can repro the issue and can confirm guillaume's analysis is correct
30878,closed,block import is broken with verkle,2601786197,MariusVanDerWijden,2025-01-20T08:51:06Z,Was this fixed by https://github.com/ethereum/go-ethereum/pull/30907 ?
30878,closed,block import is broken with verkle,2639318593,gballet,2025-02-06T09:47:23Z,"Seems to be fixed, I was able to import a few blocks from the testnet."
30892,closed,Intermittent Time Decrement Issue in Geth 1.12 Smart Contract Calls,2565822118,MariusVanDerWijden,2024-12-30T19:03:24Z,"Interesting, do you have some code for us to try to repro it better? On what kind of network are you running? Maybe in the case of a reorg where the miner mines a block a second earlier or with a bit of clock skew this might happen. 

Sorry for replying so late to this, but it would be really interesting to understand your setup!"
30892,closed,Intermittent Time Decrement Issue in Geth 1.12 Smart Contract Calls,2579641002,holiman,2025-01-09T09:56:14Z,"I sincerely don't understand this report. `setTime()` -- on what? Are we talking about a contract with a method so named? Please be specific, provide solidity-code of any contracts you refer to, and also how the contract is invoked when you detect the error. "
30892,closed,Intermittent Time Decrement Issue in Geth 1.12 Smart Contract Calls,2639318386,MariusVanDerWijden,2025-02-06T09:47:18Z,"Thank you for submitting this issue, please come back with more information. I will close this for now"
30873,closed,Unsuccessfull `geth dump`,2527108872,holiman,2024-12-09T07:07:29Z,"try `geth snapshot dump`. Much faster, if it works, since it uses the snapshot flat data instead of iterating the trie. 
Also, if you're willing to provide the output from the failed command, that'd be good, maybe we can spot some error"
30873,closed,Unsuccessfull `geth dump`,2532354029,rllola,2024-12-10T17:28:02Z,"Thanks for your answer.

The error that I have using `geth dump` is
```
missing trie node 6a9286d49a985db2aa2d5c2dc38ca7f2c69d27e7dd016ab88db1aa79f2acddd9 (path ) state 0x6a9286d49a985db2aa2d5c2dc38ca7f2c69d27e7dd016ab88db1aa79f2acddd9 is not available
```

Everytime it is a different trie and I tried specifying block numbers but always missing a trie.

I tried the `geth snapshot dump` and this time it is saying it is missing the header

full logs
```
lola@R320-Lola:~$ ./geth-linux-amd64-1.14.12-293a300d/geth snapshot dump --nostorage 21373450
INFO [12-10|12:23:13.939] Maximum peer count                       ETH=50 total=50
INFO [12-10|12:23:13.942] Smartcard socket not found, disabling    err=""stat /run/pcscd/pcscd.comm: no such file or directory""
INFO [12-10|12:23:13.945] Set global gas cap                       cap=50,000,000
INFO [12-10|12:23:13.946] Initializing the KZG library             backend=gokzg
INFO [12-10|12:23:13.987] Using pebble as the backing database
INFO [12-10|12:23:13.987] Allocated cache and file handles         database=/home/lola/.ethereum/geth/chaindata cache=512.00MiB handles=524,288
INFO [12-10|12:23:14.343] Opened ancient database                  database=/home/lola/.ethereum/geth/chaindata/ancient/chain readonly=true
header for block 21373450 not found
```
I setup this node this week end. I will try on 2 others see if I have the same result."
30873,closed,Unsuccessfull `geth dump`,2532601843,tskoyo,2024-12-10T18:46:22Z,Do you have your node synced with the latest state? The `missing trie node` and `header not found` errors usually mean that the node hasn’t fully synced up to that block or hasn’t retained the necessary historical state data.
30873,closed,Unsuccessfull `geth dump`,2535524015,rllola,2024-12-11T10:58:02Z,"I have 2 nodes that are not synced because I believe they cant catch up. And everytime I stop the state healing start from 0.

Here the log of one of them 
```
Dec 11 05:54:25 R320-Lola geth[2876943]: INFO [12-11|05:54:25.448] Forkchoice requested sync to new head    number=21,378,799 hash=24a4ce..6f003d finalized=21,378,713
Dec 11 05:54:26 R320-Lola geth[2876943]: INFO [12-11|05:54:26.066] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,799@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m18.563s
Dec 11 05:54:29 R320-Lola geth[2876943]: INFO [12-11|05:54:29.822] Syncing: state healing in progress       accounts=297,072@15.04MiB slots=512,762@39.01MiB codes=393@1.97MiB    nodes=4,881,385@1.40GiB    pending=24756
Dec 11 05:54:34 R320-Lola geth[2876943]: INFO [12-11|05:54:34.070] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,799@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m18.720s
Dec 11 05:54:37 R320-Lola geth[2876943]: INFO [12-11|05:54:37.113] Forkchoice requested sync to new head    number=21,378,800 hash=151f70..2a2bdf finalized=21,378,713
Dec 11 05:54:38 R320-Lola geth[2876943]: INFO [12-11|05:54:38.154] Syncing: state healing in progress       accounts=297,099@15.04MiB slots=512,840@39.01MiB codes=393@1.97MiB    nodes=4,881,837@1.40GiB    pending=25089
Dec 11 05:54:42 R320-Lola geth[2876943]: INFO [12-11|05:54:42.075] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,800@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m30.826s
Dec 11 05:54:46 R320-Lola geth[2876943]: INFO [12-11|05:54:46.629] Syncing: state healing in progress       accounts=297,201@15.04MiB slots=512,929@39.02MiB codes=393@1.97MiB    nodes=4,882,415@1.40GiB    pending=25241
Dec 11 05:54:49 R320-Lola geth[2876943]: INFO [12-11|05:54:49.029] Forkchoice requested sync to new head    number=21,378,801 hash=99dcfc..17fbbc finalized=21,378,713
Dec 11 05:54:50 R320-Lola geth[2876943]: INFO [12-11|05:54:50.079] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,801@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m42.936s
Dec 11 05:54:56 R320-Lola geth[2876943]: INFO [12-11|05:54:56.036] Syncing: state healing in progress       accounts=297,300@15.05MiB slots=513,003@39.03MiB codes=393@1.97MiB    nodes=4,883,048@1.40GiB    pending=25418
Dec 11 05:54:58 R320-Lola geth[2876943]: INFO [12-11|05:54:58.083] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,801@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m43.095s
Dec 11 05:55:01 R320-Lola geth[2876943]: INFO [12-11|05:55:01.197] Forkchoice requested sync to new head    number=21,378,802 hash=4617c7..b5f4a4 finalized=21,378,713
Dec 11 05:55:04 R320-Lola geth[2876943]: INFO [12-11|05:55:04.036] Syncing: state healing in progress       accounts=297,354@15.05MiB slots=513,081@39.03MiB codes=393@1.97MiB    nodes=4,883,533@1.40GiB    pending=25488
Dec 11 05:55:06 R320-Lola geth[2876943]: INFO [12-11|05:55:06.089] Syncing: chain download in progress      synced=100.00% chain=832.40GiB headers=21,378,802@10.13GiB bodies=21,378,697@601.58GiB receipts=21,378,697@220.69GiB eta=20m55.209s
```

The other node is one of a friend and yes it is synced. Also I have to stop the node to do a dump so it is annoying.
But same result I have missing tries or when doing snapshot I have missing headers message."
30873,closed,Unsuccessfull `geth dump`,2579630123,holiman,2025-01-09T09:50:58Z,"> The other node is one of a friend and yes it is synced.

It's not worth trying to dump from the nodes that are not synced, so let's ignore those. On this node which has finished syncing, what happens when you attempt a dump? 

"
30873,closed,Unsuccessfull `geth dump`,2579637537,rllola,2025-01-09T09:54:34Z,"I have the same message as the others which was some like this :
```
missing trie node 6a9286d49a985db2aa2d5c2dc38ca7f2c69d27e7dd016ab88db1aa79f2acddd9 (path ) state 0x6a9286d49a985db2aa2d5c2dc38ca7f2c69d27e7dd016ab88db1aa79f2acddd9 is not available
```

I am curious to know if anyone has tried and successfully dumped snapshot with the current version ? "
30873,closed,Unsuccessfull `geth dump`,2639314642,rjl493456442,2025-02-06T09:45:34Z,"> lola@R320-Lola:~$ ./geth-linux-amd64-1.14.12-293a300d/geth snapshot dump --nostorage 21373450

Your node is not fully synced. Please wait until you see the logs like `Imported new chain segment`"
30948,closed,all: update license headers and AUTHORS,2565313471,ronething-bot,2024-12-30T10:46:31Z,"> We don't update the year in the license header.

@MariusVanDerWijden Hi, thanks for your review comment.

The year modification of the license header is due to this section of logic processing, ref: https://github.com/ethereum/go-ethereum/blob/25aa8f6d7fe82e313f4bab0a6a6f834ee7315ce6/build/update-license.go#L362-L364

Running `build/update-license.go` will automatically modify it, and I will revert the modified year of the license header later, or only keep the modifications to the `AUTHORS` file.
"
30948,closed,all: update license headers and AUTHORS,2567267556,ronething-bot,2025-01-02T04:06:12Z,"@rjl493456442 PTAL, thanks."
30948,closed,all: update license headers and AUTHORS,2571274281,fjl,2025-01-04T12:29:44Z,"It's good to update, but the AUTHORS file requires some manual review. Specifically, we need to ensure that entries are unique. There are two kinds of entries in the file: name + email, and github users. When people contribute via GitHub, it usually uses their GitHub username as the committer. However, some people also push commits with their own email address, and this can lead to duplicates in AUTHORS. The way to resolve that is adding entries into the `.mailmap` file. I usually update this file whenever we update AUTHORS to ensure there are no obvious duplicates.
"
30948,closed,all: update license headers and AUTHORS,2571279437,ronething-bot,2025-01-04T12:50:28Z,"> The way to resolve that is adding entries into the .mailmap file. I usually update this file whenever we update AUTHORS to ensure there are no obvious duplicates.

@fjl I have updated the duplicate items to `.mailmap` file, please review the latest commit, thanks

ref: https://github.com/ethereum/go-ethereum/pull/30948/commits/7cd59414a355cf94656cd65a901117ac5db22c6a"
30948,closed,all: update license headers and AUTHORS,2571284815,fjl,2025-01-04T13:12:44Z,Thanks. I will do another pass myself later.
30948,closed,all: update license headers and AUTHORS,2579113584,ronething-bot,2025-01-09T03:32:03Z,"@fjl May I ask if this PR can be continued to be pushed forward, thanks?"
30948,closed,all: update license headers and AUTHORS,2607759660,ronething-bot,2025-01-22T16:50:34Z,"Hi, just checking in to see if there’s any update on this PR. Let me know if there’s anything I can help with. Thanks."
30948,closed,all: update license headers and AUTHORS,2608054604,fjl,2025-01-22T19:09:28Z,@ronething-bot I will get to it shortly.
30948,closed,all: update license headers and AUTHORS,2638079064,fjl,2025-02-05T21:37:40Z,I have resubmitted this as https://github.com/ethereum/go-ethereum/pull/31133. It was easier to just run the script again than trying to rebase this.
30441,closed,core/tracing: state journal wrapper,2400315196,s1na,2024-10-08T16:21:14Z,"Ah seems like the journal has a crasher:

```
revisions: [{0 2} {1 4} {2 4} {3 4} {4 6} {5 6} {6 9} {7 11} {8 12} {9 18} {10 18} {11 20} {12 22} {13 24} {14 24} {18 27}]
panic: revision id 17 cannot be reverted

goroutine 10470 [running]:
github.com/ethereum/go-ethereum/core/tracing.(*journal).revertToSnapshot(0xc050c41c70, 0x11, 0xc0570360e0)
        github.com/ethereum/go-ethereum/core/tracing/journal.go:170 +0x185
github.com/ethereum/go-ethereum/core/tracing.(*journal).OnExit(0xc050c41c70, 0x0, {0xc13a87fe30, 0x64, 0x64}, 0x48dc9, {0x203f680, 0xc018bcc978}, 0x1)
        github.com/ethereum/go-ethereum/core/tracing/journal.go:206 +0x6f
github.com/ethereum/go-ethereum/core/vm.(*EVM).captureEnd(0xc13a9e0780?, 0x0, 0x12e208, 0xe543f, {0xc13a87fe30, 0x64, 0x64}, {0x203da40, 0x2e05070})
```"
30441,closed,core/tracing: state journal wrapper,2405009796,daleksov,2024-10-10T12:53:37Z,"> I don't see any need for these: `OnBalanceRead` etc. It adds non-generic handlers for certain opcodes, but a more generic solution already exists, using the per-opcode step function.
> 
> Here's the old prestate tracer js:
> 
> ```js
> 	// step is invoked for every opcode that the VM executes.
> 	step: function(log, db) {
> 		// Add the current account if we just started tracing
> 		if (this.prestate === null){
> 			this.prestate = {};
> 			// Balance will potentially be wrong here, since this will include the value
> 			// sent along with the message. We fix that in 'result()'.
> 			this.lookupAccount(log.contract.getAddress(), db);
> 		}
> 		// Whenever new state is accessed, add it to the prestate
> 		switch (log.op.toString()) {
> 			case ""EXTCODECOPY"": case ""EXTCODESIZE"": case ""EXTCODEHASH"": case ""BALANCE"":
> 				this.lookupAccount(toAddress(log.stack.peek(0).toString(16)), db);
> 				break;
> 			case ""CREATE"":
> 				var from = log.contract.getAddress();
> 				this.lookupAccount(toContract(from, db.getNonce(from)), db);
> ```
> 
> The existing way to it is arguably slower, since it's on the hot-path and invoked on every opcode. We could mitigate that, if e.g. tracers declare a whitelist of ops that they are interested in (e.g. optionally expose a method which spits out a list).
> 
> The existing way is perhaps a bit clunky, in that it's up to the tracer to make sense of the stack arguments, but otoh the stack arguments are not something that is changed frequently, since it's consensus-critical, and can only be changed in hardforks.
> 
> It's also a bit clunky to see the poststate: for op `X`, you see the stack prior to the execution of `X`. In order to see the stack _after_ , you need to check on the next op too. Which might be difficult, especially if we have whitelisted `X` only -- but we could improve this too, e.g. by using a returnvalue saying `hey I want to be notified about the next op too`.
> 
> All in all, I think we should iterate on the existing generic solution, and not litter the code with these hooks.

Hi @holiman,

We're really excited about the live tracing feature and see immense value in it, especially for our specific use case. Currently, we fetch blocks from nodes (clients) in a polling fashion and re-execute them using a customized EVM that performs more detailed tracing. By utilizing live tracing directly on the node (client), we can significantly boost both performance and correctness, and it would allow us to completely remove the re-execution and re-processing logic from our pipeline. This is why having more explicit hooks, like OnBalanceRead and others, is crucial for us. These hooks would allow us to optimize our tracing workflow, making it more efficient and accurate, which is why we strongly favor this approach and would love to keep it in place.

Here are some of the key benefits we see in favor of keeping the more explicit hooks:

**Accurate State Tracking**
Explicit read hooks ensure immediate and precise state initialization (like balances and nonces) during live tracing. Without them, we'd have to manually infer state access from opcodes, adding complexity and increasing the chance of errors.

**Separation of Concerns**
By using explicit read hooks, we separate state management from opcode handling, keeping the code cleaner, more modular, and easier to maintain. This avoids cluttering the opcode logic and reduces the risk of introducing bugs.

**State Consistency**
These hooks capture essential pre-state information (before any changes happen), which is crucial for our use case, ensuring accurate comparisons between pre- and post-execution states, especially for debugging and analysis which is essential for us and all our customers.

**Performance Optimization**
Explicit read hooks allow us to focus on relevant state interactions without needing to manually parse the stack for every opcode. This simplifies the logic and reduces performance overhead on our tracer side by handling only the necessary state accesses.

**Future-Proofing:**
As Ethereum evolves, explicit read hooks for fundamental state elements like account balances and nonces provide the flexibility to handle new state access patterns, even in the event of **future hard forks**. This ensures that the tracer can adapt without requiring major changes to the code, allowing it to remain compatible with protocol updates and any state access modifications introduced through hard forks.
Additionally, maintaining this pattern helps ensure consistency across different Go-Ethereum forks, forcing them to support live-tracing without breaking its functionality, thereby preserving compatibility across ecosystems.

**Transition from Full Archive to Full Node**
The most beneficial aspect for us is the ability to move from a full archive node to a full node. Through live tracing, we can store state information and re-execute transactions that are older than 128 block"
30441,closed,core/tracing: state journal wrapper,2405058194,holiman,2024-10-10T13:12:30Z,"> Explicit read hooks ensure immediate and precise state initialization (like balances and nonces) during live tracing. Without them, we'd have to manually infer state access from opcodes, adding complexity and increasing the chance of errors.

For `nonce`, a `nonce` is opaque from the evm execution (it is implicitly visible whenever a contract is created via `CREATE`, where the address depends on the nonce). Why do you want a read access for that? It is only ever modified during contract-creation or during state processing, when the transaction sender nonce is increased. 

For `balance`, there's `SELFBALANCE` and `EXTBALANCE` (a.k.a `BALANCE`). These take an address on the stack, and leave the balance on the stack. It's pretty straight-forward, with the caveat that you'd want to capture both the pre-exec (inputs) and post-exec (outputs). Alternativly, you can ignore the post-exec, and simply fetch the balance at this point, which would fulfill the requirement: ""essential pre-state information (before any changes happen), which is crucial for our use case,""
"
30441,closed,core/tracing: state journal wrapper,2405121942,holiman,2024-10-10T13:38:34Z,"Note, if we can get something like this to work, then I'm a lot more open to having all sorts of hooks: https://github.com/ethereum/go-ethereum/pull/30569

I don't like the deep integration, but if it's possible via a separate layer then ""let's go wild"" imo

"
30441,closed,core/tracing: state journal wrapper,2409939903,s1na,2024-10-14T04:49:47Z,@fjl regarding the backwards-compatibility I have for now added a `OnSystemCallStartV2` in the same hooks object. What do you think?
30441,closed,core/tracing: state journal wrapper,2419021596,s1na,2024-10-17T09:25:42Z,I dropped OnReorg and merged in changes from master.
30441,closed,core/tracing: state journal wrapper,2434259393,s1na,2024-10-24T04:29:42Z,"I have pulled in the latest master changes and moved the state read hooks over to the hooked statedb.

One thing to know about the state read hooks: They will not give you the full prestate by themselves. You will need also the previous values emitted as part of state change hooks. This is because e.g. statedb.AddBalance does not do statedb.GetBalance internally."
30441,closed,core/tracing: state journal wrapper,2501119157,s1na,2024-11-26T15:19:59Z,"Copying from the chat with @nebojsa94:

> Also, regarding jorunaling logic on your branch tracing V1.1, there’s an edge case with failed contract creation where the nonce is reverted, but it shouldn’t be. This happens because CaptureEnter is triggered before the nonce is incremented for contract creation prior to state snapshotting."
31101,closed,"consensus/misc/eip4844: use head's target blobs, not parent",2630739171,s1na,2025-02-03T11:55:53Z,The diff to #31002 looks good!
31101,closed,"consensus/misc/eip4844: use head's target blobs, not parent",2634743132,lightclient,2025-02-04T18:23:57Z,"Fixed up based on review comments, thx."
31067,closed,core: assign default difficulty to zero for chain without ethash,2609878638,rjl493456442,2025-01-23T13:58:15Z,CI is failing
31067,closed,core: assign default difficulty to zero for chain without ethash,2633850336,MariusVanDerWijden,2025-02-04T13:05:57Z,Ah looks like there is a test failing with this
31067,closed,core: assign default difficulty to zero for chain without ethash,2634446553,fjl,2025-02-04T16:15:26Z,"I think that #31123 wasn't too bad and we should reconsider making a more fundamental change. In this PR I just tried to make a minimally-invasive fix for my issue, but the logic is very unintuitive."
31096,closed,.travis.yml: change arch for Docker build to arm64,2624028355,fjl,2025-01-30T09:59:20Z,This will likely not fix the issue we are seeing. It's also reported here: https://gitlab.alpinelinux.org/groups/alpine/-/issues/?sort=created_date&state=opened&search=gcc&first_page_size=20
31113,closed,tests/fuzzers/bls12381: fix error message in fuzzCrossG2Add,2630808149,MariusVanDerWijden,2025-02-03T12:26:56Z,"Looks like you fixed it in the wrong place, you fixed it in `fuzzCrossG1Add`"
31113,closed,tests/fuzzers/bls12381: fix error message in fuzzCrossG2Add,2631977780,0xkazak,2025-02-03T20:15:15Z,"> Looks like you fixed it in the wrong place, you fixed it in `fuzzCrossG1Add`

[MariusVanDerWijden](https://github.com/MariusVanDerWijden), fixed. "
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2440729213,rjl493456442,2024-10-28T07:16:52Z,"I think the general idea is good and it's a good direction to ""distribute the complexity"" of txpool graduately."
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2454178669,holiman,2024-11-04T09:17:26Z,`TestUnderpricing` is flaky in this PR. Not sure why
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2539159802,holiman,2024-12-12T14:47:05Z,"> `TestUnderpricing` is flaky in this PR. Not sure why

Fixed (crosses fingers)"
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2568185048,MariusVanDerWijden,2025-01-02T18:21:18Z,I'm wondering whether we should save users from shooting themselves in the foot by only allowing non-blob transactions in the tracker
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2568990112,MariusVanDerWijden,2025-01-03T10:14:36Z,"Overall this PR looks very good to me. I love the concept and implementing it as an additional service is genius. I added some minor comments where this PR changes the behavior of the transaction pool, they boil down to the following:

- previously local blob transactions were not tracked, now they are tracked and journalled
- Invalid transactions might make it into the tracker, previously only txs that passed the basic validation would be tracked
- Only addresses that are configured on startup will get priority, previously all txs from accounts that were sent via RPC got prio
- Remote txs from a sender that once sent via the RPC were still considered local and tracked, now they are not anymore

I'm not saying that all of those are issues that need to be fixed necessarily, I think we should discuss them though before merging this PR to make sure we don't rug users"
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2569219012,holiman,2025-01-03T13:25:20Z,"Thanks. Re the last two points, they are described fully in the PR description. 
The first two points should probably be undone"
30559,closed,core/txpool: remove locals-tracking from pools (part 2) ,2574723467,holiman,2025-01-07T08:54:01Z,"Thanks @MariusVanDerWijden, I have addressed the points you raised. Also rebased on master"
31002,closed,"params,core: add max and target value to chain config",2583035276,lightclient,2025-01-10T15:54:45Z,"Made the updates from your review, Marius. Thanks!"
31002,closed,"params,core: add max and target value to chain config",2622757283,lightclient,2025-01-29T20:20:05Z,PTAL
31120,closed,rpc: fix go-routine leaks in client handler,2630591270,ilia-tsyplenkov,2025-02-03T10:47:57Z,"it doesn't break any other tests:
```
i-tsyplenkov@Ilias-MacBook-Air rpc % go test ./...
ok  	github.com/ethereum/go-ethereum/rpc	10.783s
i-tsyplenkov@Ilias-MacBook-Air rpc % echo $?
0
```"
31120,closed,rpc: fix go-routine leaks in client handler,2631989653,ilia-tsyplenkov,2025-02-03T20:20:19Z,wrong solution. it breaks server logic. I provide an update if I'll find the correct solution
31120,closed,rpc: fix go-routine leaks in client handler,2632107927,fjl,2025-02-03T21:24:06Z,"Let be known that we don't really care about minor resource leaks in tests. We have the general rule that code that will be used as a library has to clean up after itself. RPC client and server do not leave goroutines behind when they terminate. But tests run as a short-lived process, and it can sometimes be easier to not add all necessary synchronization to ensure all goroutines are fully ended with the test."
31120,closed,rpc: fix go-routine leaks in client handler,2633984756,MariusVanDerWijden,2025-02-04T13:38:43Z,"We've discussed this a bit internally and decided not to go forward with this, because of the reasons outlined by @fjl. 
Thank you for submitting this anyway @ilia-tsyplenkov!"
